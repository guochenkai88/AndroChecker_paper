\section{Introduction}
With the rapid development of mobile devices, interactions with such devices have already become indispensable to people's daily life. To support the increasing requirements of users, there has been a surge in developing mission-critical programs  running on the devices, called \textit{apps}. Nowadays, although Android apps have already dominated the mobile market, there still are vast number of apps being produced every day. However, the growing number of apps also raise the quality concerns, e.g., reducing potential bugs and improving security. The problem that how to verify the correctness and security of such apps has become a critical concern for both developers and users.

Event-driven is known as a representative feature in Android system, yet raising intractable issues on testing and verification. Since Android app does not have a fixed program entry, traditional flow analysis \cite{new1976program, new1978dataflow} is hard to be directly adopted on it. Considering Android framework is complex and full of event-driven structures (e.g, listener interfaces, event callbacks, etc.), static analysis for Android normally choose to create models of certain Android app rather than analyze the app source code itself. There are two types of app modelling manners in term of the model object: \textit{callback-directed} \cite{new2013contextual,new2015static} and \textit{data-directed} \cite{new2014flowdroid, new2015DroidSafe}. Callback-directed modelling captures event-callback sequences within targeted app and represents them as specialized control flow graph (\textit{CFG}); while data-directed modelling identifies certain types of information related to the analysis goal and combines these information according to the flow sequences. The former manner is more versatile and able to provide logical architecture over the entire app program. However, pure callback-directed modelling is hard to provide concrete assist for analysis in practical scenarios. Most of the modelling targets, whether functionality testing or security verification, are closely combined with solid data input and output.
The latter manner has advantages in tackling issues in specific or partial regions, but need to balance the cost in constructing a generic model. 

In current stage, whether callback-directed or data-directed manners has not conducted the modelling in a generic and fine-grained way. The reason is that Android is equipped with many complex features such as inter-process communication and vast callback SDKs (Software Development Kit). As a result, the generated model by previous works \cite{new2013contextual,new2015static, new2015window} is incomplete. In detail, the incompleteness is reflected in three aspects. 1) Single component type: only \texttt{activity} is involved in modelling analyses, ignoring other components like \texttt{service} and \texttt{broadcast receiver}. In fact, security compromises and logic bugs frequently exist in those components. 2) Incomplete callback types: only callbacks related to lifecycle and user interaction are taken into consideration. Actually, in Android, a variety of callbacks are driven by system events, like phone and location status. Although these system-driven callbacks are invoked out of user's intention, they are of importance in analyzing certain system status. 3) Path-insensitive: in previous callback modelling, the generated edges only present a \textit{possible} flow from start node to end node. Consequently, the generated model makes it unclear how and when the flow is executed. In practice, barely offering a group of \textit{possible} paths helps little to analysis. For example, techniques for test cases generation normally need to confirm the condition ranges for specifying certain program paths. In other words, the test cases are determined by the condition data rather than the paths themselves. Therefore, constructing a path-sensitive model benefits more in further application.    

In this work, we take advantages of both callback-directed and data-directed modelling. We seek to explore a generic, event-callback related modelling approach to handle the critical condition data that impacts the direction of control flows. The object of our work is to automatically construct a generic path-sensitive callback (\textit{GPC} for short) model for each Android app. There are three key insights underlying our approach: 1) components like service run in a parallel way with other components; 2) each of the non-lifecycle callbacks needs to register itself in their parent callbacks first; 3) the callback execution condition can be identified by analyzing the register implementation along with possible paths. Our approach leverages above insights to fully automate the model construction via static program analysis. 

We design and implement a proof-of-concept model builder AndroChecker, which receives Android \textit{apk} file as input and outputs corresponding \textit{GPC} model. We apply AndroChecker to 20 real-world apps. The evaluation results show that our technique is both accurate and complete. 

The main contributions of this paper can be concluded as followings: 
\begin{itemize}
\item Definition of the \textit{GPC} model, a generic path-sensitive callback model, for understanding, testing and statically verifying Android apps
\item Algorithm to construct the \textit{GPC} model, adopting backward data dependency analysis
\item Implementation of a proof-of-concept model builder AndroChecker
\item Experimental evaluation on 20 real-world apps, as well as three case studies
\end{itemize}

%Insight: 1) most of the firing of callbacks must obey specific conditions, which is relevant to not only resource file\cite{}, but also data dependency.
%2) the same callback varies under different driven.(prefix sensitive)
%3) There exists impact between intra-components.(create a novel graph)
%
%In this work, we focus on constructing a generic, deep context-sensitive, cross-components framework for callback transition analysis. We seek to solve a problem 
%
%Our approach is based on deep context reasoning