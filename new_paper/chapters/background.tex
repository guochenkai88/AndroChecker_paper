\section{Background} \label{background}
Android is known as the domain operating system for mobile devices, which is based on Linux, middleware and vast of core libraries. Developers can develop specialized apps using the libraries offered by Android. The main program modules of Android apps are called \textit{components}. There are four types of component in Android system: activity, service, broadcast recevier and content provider. \textit{Activity} is used to handle tasks for interacting with user; while \textit{service} handles computing tasks in the background. A \textit{broadcast recevier} is used to respond to the broadcast from system or other components. A \textit{content provider} works for data management. The communication between components relies on \textit{intent}.

Typically, Android program is event-driven and lacks an explicit fixed entry point for program execution.  
Instead, the app execution is driven by certain events from either system or user. Each component within the app consists of a number of callbacks to respond to the events. Normally Android callbacks are implemented by overriding methods in relative listener interfaces. Here we divide the callbacks into three categories in terms of their usages.
 
\textbf{Lifecycle callbacks} respond to lifecycle events that reflect life stages of holder component. In the four types of component, activity supports a more complex lifecycle since it acts as a main channel for interacting with user. As a result, prior works tend to construct activity-oriented model. Yet, other components also have their own lifecycle callbacks though simpler. Specifically, service has two sets of different lifecycle callbacks, supporting binding and launching operations from other component, respectively. 

\textbf{\textit{GUI} callbacks} handle the visual interaction with user. Therefore they are normally implemented in activity. \textit{GUI} callbacks are implemented in the listener interfaces that have a common superclass \texttt{android.view.View}. These interfaces need to be registered in other callback via API like \texttt{setOnClickListener}.

\textbf{System-driven callbacks} are normally invoked when a specific system status changes. Analogous with \textit{GUI} callbacks, system-driven callbacks are held by certain Android listener interfaces. These interfaces start to listen specialized events after they are registered and end the listening when they are unregistered. Though vast of system listener interfaces are supplied in Android, they adopt similar register and unregister manners connecting the holder callbacks with corresponding system-driven callbacks. 

We call the \textit{GUI} and system-driven callbacks \textit{non-lifecycle callback} hereafter. Non-lifecycle callbacks are always invoked in specialized \textit{running interval} for each component. In activity, the running interval refers to the region between \texttt{onResume} and \texttt{onPause}. In service, the interval is located between \texttt{onStartCommand} and \texttt{onDestroy}, or \texttt{onBind} and \texttt{onUnbind}.

\textit{Callback control flow} \textit{CCF} (callback control flow)\cite{new2015static} presents underlying time sequences for each callback. For lifecycle callbacks, the flow sequences are simply along with the lifecycle sequences. However, as mentioned before, non-lifecycle callbacks have to be registered before they are invoked via events. Thus the holder callback $ \eta $ has to be invoked before the registered callback $ \zeta $. In this way, there exists a potential flow from $ \eta $ to $ \zeta $, denoted as $ \eta \rightarrow \zeta $. Actually, $ \zeta $ are not directly invoked by $ \eta $, but activated when $ \eta $ is invoked. The edge $ \rightarrow $ reflects a \textit{possible} invocation sequence between $ \eta $ and $ \zeta $. Here the \texttt{onReceive} callback of broadcast receiver is also regarded as non-lifecycle callbacks. Dynamically registered broadcast receiver acts as an event listener within the holder component (activity or service). At the same time, broadcast receiver statically registered in the \textit{Androidmanifest.xml} runs along with foreground activity. Therefore, it can be treated as the event listener of foreground activity although there is not a specified fixed holder. Note that we don't consider the content provider in this work since it is only used for data management and it lacks of useful callback implementation. 

Another flow type within the \textit{CCF} comes from the inter-components invocation where the invoker and invokee components are combined by connection site like \texttt{startActivity} and \texttt{startService}. If both of the invoker $ \eta $ and invokee $ \zeta $ belong to activity, there exists s strict time sequence $ \eta \rightarrow \zeta $. When the invokee activity starts running on the foreground, the invoker has already been moved to background and stopped running. If either the invoker or invokee involves service, the invocation will be treated as \textit{parallel edge} since service can run in parallel with other components, which is not considered in \cite{new2015static}. At this time, the sequence between the invoker and the invokee is flexible. In the inter-component cases, the \texttt{onCreate} of the launcher activity (registered as \texttt{android.intent.category.LAUNCHER} in the \textit{Androidmanifest.xml}) is treated as the entry point of entire system.