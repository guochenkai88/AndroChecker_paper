\section{Generic Path-sensitive Callback Model}\label{transition-model}
In this section, we introduce the \textit{GPC} model and define related conceptions. 

\textbf{Definition 1.} A \textit{Generic Path-sensitive Callback Model} (\textit{GPC}) is a tuple
\begin{equation}
GPC = (N, E, C)
\end{equation}
consisting of the followings.
\begin{itemize}
\item \textit{N} is the nodes set that represents the set of callbacks. The \textit{N} contains three parts and is denoted as $ N = \{N_{l}, N_{n} \} $.  $ N_{l}$ refers to the set of lifecycle callbacks, $N_{l}= \{N_{lfc}, N_{aux}\} $ , in which $N_{lfc}$ and $N_{aux}$ refer to the set of system and auxiliary lifecycle. Auxiliary nodes set $ N_{aux}$ is added into lifecycle modelling for auxiliary analysis, which contains three defined callbacks \textit{ActiveStart}, \textit{ActiveEnd} and \textit{Terminal}, $ N_{aux} = \{N_{as}, N_{ae}, N_{tm} \} $. Correspondingly, $ N_{n}$ refers to the set of non-lifecycle callbacks, $ N_{n} = \{N_{sys}, N_{gui} \} $, in which $N_{sys}$ and $N_{gui}$ refer to the set of system and gui callbacks. In addition, we denote the nodes of component \textit{x} as $N^{x}$, the start node as $ N_{st}$ and the restart node as $ N_{re}$. 
\item \textit{E} is the edges set that represents the invocation sequence between two nodes. \textit{E} can be generated via three ways: lifecycle event, register action and inter-component jumping. We denote them as $ E = \{E_{l}, E_{r}, E_{j} \} $, in which $ E_{l} = N_{l} \times N_{l}$ , $ E_{r}  = (N_{l} \times N_{n}) \cup (N_{n} \times N_{l}) \cup (N_{n} \times N_{n})$ and $ E_{j} = \{E_{j-a}, E_{j-s}\} = (N_{tm}^{a} \times N_{st}^{b}) \cup (N_{tm}^{b}\times N_{re}^{a})$. In the definition of $ E_{j}$, $E_{j-a}$ refers to the inter-component edges between activities; $E_{j-s}$ refers to the ones involving service component.
\item \textit{C} is the conditions set for nodes, $ C = (Ivr, \Lambda, Ive)$, in which \textit{Ivr} refers to the invoker callbacks set; \textit{Ive} is the invokee callbacks set; $\Lambda$ is the condition data set performing as a boolean expression of variables. In detail, $\Lambda : Val \rightarrow \{True, False\}$, in which \textit{Val} is the assigned values of condition's variables.
\end{itemize}

\textbf{Definition 2.} \textit{Register Abstraction} (\textit{RA}) is the set of actions for register (FRA) and unregister (BRA) of the non-lifecycle callbacks, which is denoted as a tuple
\begin{equation}
RA = (Ivr, \Gamma, Ive)
\end{equation}
consisting of the following elements:
\begin{itemize}
\item \textit{Ivr} and \textit{Ive} refer to the set of invoker and invokee callback respectively.
\item $ \Gamma $ refers to set of register (for FRA) and unregister (for BRA) action. $ \Gamma $ contains two parts: object and API, namely $ \Gamma = (obj, API)$, in which the object conducts (un)register action and the API is employed by the object.
\end{itemize}

To clarity, we take the motivation example for illustration. As for register action in line 12, the \textit{FRA} can be denoted as  \texttt{(onResume,(locationManager,requestLocationUpda\\
tes), onLocationChanged)}; for the unregister action in line 19, the \textit{BRA} can be denoted as  \texttt{(onPause,(locationManager,removeUpda\\
tes), onLocationChanged)}.



\textbf{Definition 3.} \textit{Jumping Abstraction} (\textit{JA}) is the action that launches (\textit{FJA}) and terminates (\textit{BJA}) new component \textit{b} from current running component \textit{a}, which is denoted as a tuple 
\begin{equation}
JA = (Ivr^{a}, \Upsilon, Ive^{b})
\end{equation}
consisting of the following elements:
\begin{itemize}
\item For \textit{FJA}, $Ivr^{a}$ and $Ive^{b}$ refer to the launcher callback in \textit{a} and the launched callback in \textit{b} respectively.
Correspondingly, for \textit{BJA}, \item $Ivr^{a}$ refers to the callback in \textit{a} for terminating \textit{b}; and $Ivr^{b}$ refers to the callback in \textit{b} terminated by \textit{a}.
\item $ \Upsilon $ refers to the set of jumping actions in the invoker component (i.e., \textit{a}). Similar as \textit{RA}, $ \Upsilon $ also contains the object and API, namely $ \Upsilon = (obj, API)$, which refers to the jumping object and employed API.
\end{itemize}

In the motivation example, as for jumping action in line 29, the jumping abstraction can be denoted as \texttt{(ShareMyPosition\$2}$\rightarrow$\texttt{onClick,(ShareMyPosition.\\
this,startActivity),share}$\rightarrow$\texttt{onCreate)}. Note that \texttt{ShareMyPosition\$2} is the inner anonymous class of \texttt{ShareMyPosition}, which contains the invoker \texttt{onClick}.


The \textit{RA}, \textit{JA} and the lifecycle flow set (\textit{LF}) are three key types of connections between callback nodes. The \textit{GPC} edges are generated by identifying these flow sets. The correlations between the defined connections and edges are shown as
$RA \Rightarrow E_{r}$,
$JA \Rightarrow E_{j}$, and
$LF \Rightarrow E_{l}$.

\textbf{Definition 4.} \textit{Event} is the situation that triggers the invocation of callback, which is denoted as a tuple
\begin{equation}
Event = (Tgr, Act, Obj)
\end{equation}
consisting of the following elements:
\begin{itemize}
\item \textit{Tgr} refers to the object that conducts the trigger action. The \textit{Tgr} has two selectable items: \textit{user} and \textit{system}.
\item \textit{Act} refers to the trigger action. Typical \textit{Act} includes \textit{Click}, \textit{Touch}, \textit{LocationChanged}, etc.
\item \textit{Obj} refers to the triggered object. Typical \textit{Obj} includes instances of \textit{Button}, \textit{View}, \textit{LocationManager}, etc.
\end{itemize}

\textbf{Definition 5.} \textit{HiddenNodes} represents the unimplemented lifecycle callbacks in the target app. The \textit{hiddenNodes} set can be computed by the formulation
 $ HiddenNodes = ELG.nodes - N(l) $, where \textit{ELG.nodes} is the entire lifecycle nodes.

\textbf{Definition 6.} \textit{Active Area} is a lifecycle interval where the non-lifecycle callbacks are normally invoked.

The active area is quite different in activity and service. For activity, the active area is located between \texttt{onResume} and \texttt{onPause}; for service, it is located between \texttt{onStartCommand} and \texttt{onDestroy}, or between \texttt{onBind} and \texttt{onUnbind}(for service with \texttt{onbind} callback). The auxiliary nodes \textit{onActiveStart} and \textit{onActiveEnd} are initialized to identify the active area. For instance, a partial picture of activity's lifecycle model is  $onResume\rightarrow onActiveStart\rightarrow onActiveEnd\rightarrow onPause$.
Note that the we do not consider the extreme situation where non-lifecycle callbacks are invoked outside the \textit{Active Area}.